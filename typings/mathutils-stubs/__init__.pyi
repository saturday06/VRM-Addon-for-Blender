# SPDX-License-Identifier: MIT OR GPL-3.0-or-later
from collections.abc import Iterable, Iterator, Sequence
from typing import Optional, TypeVar, Union, overload

# TODO: 引数のIterableは本当はSequenceだったりしないか?

__MatrixFallbackType = TypeVar("__MatrixFallbackType")

class Matrix:
    def __init__(self, rows: Sequence[Sequence[float]] = ()) -> None: ...
    def copy(self) -> Matrix: ...
    @classmethod
    def Translation(cls, vector: Iterable[float]) -> Matrix: ...
    @classmethod
    def Rotation(cls, angle: float, size: int, axis: Union[str, Vector]) -> Matrix: ...
    @classmethod
    def Identity(cls, size: int) -> Matrix: ...
    @classmethod
    def Diagonal(cls, vector: Iterable[float]) -> Matrix: ...
    @overload
    def inverted(self) -> Matrix: ...
    @overload
    def inverted(
        self, fallback: __MatrixFallbackType
    ) -> Union[Matrix, __MatrixFallbackType]: ...
    @overload
    def __matmul__(self, other: Matrix) -> Matrix: ...
    @overload
    def __matmul__(self, other: Vector) -> Vector: ...
    def to_translation(self) -> Vector: ...
    def transpose(self) -> None: ...
    def __getitem__(self, index: int) -> Vector: ...
    def __len__(self) -> int: ...
    def inverted_safe(self) -> Matrix: ...
    def transposed(self) -> Matrix: ...
    def decompose(self) -> tuple[Vector, Quaternion, Vector]: ...
    def to_4x4(self) -> Matrix: ...
    @property
    def translation(self) -> Vector: ...
    def to_quaternion(self) -> Quaternion: ...
    def to_scale(self) -> Vector: ...
    def __iter__(self) -> Iterator[Vector]: ...

class Vector(Sequence[float]):
    x: float
    y: float
    z: float

    def __init__(self, seq: Iterable[Union[int, float]]) -> None: ...
    def copy(self) -> Vector: ...
    def __truediv__(self, other: float) -> Vector: ...
    def __setitem__(self, index: int, value: float) -> None: ...
    def __add__(self, other: Vector) -> Vector: ...
    def __sub__(self, other: Vector) -> Vector: ...
    def __mul__(self, other: float) -> Vector: ...
    def __matmul__(self, other: Matrix) -> Vector: ...
    @overload
    def __getitem__(self, index: int) -> float: ...
    @overload
    def __getitem__(
        self, index: slice[Optional[int], Optional[int], Optional[int]]
    ) -> tuple[float, ...]: ...
    def __iter__(self) -> Iterator[float]: ...
    @property
    def length(self) -> float: ...
    @property
    def length_squared(self) -> float: ...
    def cross(self, other: Vector) -> Vector: ...
    def normalize(self) -> None: ...
    def dot(self, other: Vector) -> float: ...
    def __neg__(self) -> Vector: ...
    def __len__(self) -> int: ...
    def normalized(self) -> Vector: ...
    def negate(self) -> None: ...
    def rotate(self, other: Union[Euler, Quaternion, Matrix]) -> None: ...
    def rotation_difference(self, other: Vector) -> Quaternion: ...
    def lerp(self, other: Vector, factor: float) -> Vector: ...
    def angle(
        self,
        other: Vector,
        fallback: Optional[float] = None,
    ) -> float: ...  # fallbackの型のドキュメントが曖昧
    @property
    def magnitude(self) -> float: ...

class Quaternion:
    x: float
    y: float
    z: float
    w: float

    angle: float

    @overload
    def __init__(
        self,
        seq: Union[Vector, Iterable[Union[int, float]]],
        angle: float,
    ) -> None: ...
    @overload
    def __init__(
        self,
        wxyz: Union[Vector, Iterable[Union[int, float]]],
    ) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def copy(self) -> Quaternion: ...
    def rotate(self, other: Union[Euler, Quaternion, Matrix]) -> None: ...
    def to_matrix(self) -> Matrix: ...
    def normalize(self) -> None: ...
    def normalized(self) -> Quaternion: ...
    @overload
    def __matmul__(self, other: Quaternion) -> Quaternion: ...
    @overload
    def __matmul__(self, other: Vector) -> Vector: ...
    def __setitem__(
        self,
        index: int,
        value: float,
    ) -> None: ...  # ドキュメントには存在しない?
    def to_euler(
        self,
        order: str = "XYZ",
        euler_compat: Optional[Euler] = None,
    ) -> Euler: ...
    def to_axis_angle(self) -> tuple[Vector, float]: ...
    def inverted(self) -> Quaternion: ...
    def slerp(self, other: Quaternion, factor: float) -> Quaternion: ...
    def rotation_difference(self, other: Quaternion) -> Quaternion: ...

class Color:
    def __init__(self, rgb: Iterable[float]) -> None: ...
    def copy(self) -> Color: ...
    def freeze(self) -> Color: ...
    b: float
    g: float
    h: float
    @property
    def hsv(self) -> tuple[float, float, float]: ...
    @hsv.setter
    def hsv(self, value: Sequence[float]) -> None: ...
    @property
    def is_frozen(self) -> bool: ...
    @property
    def is_wrapped(self) -> bool: ...
    def owner(self) -> object: ...
    r: float
    s: float
    v: float

class Euler:
    def __init__(self, angles: Iterable[float], order: str = "XYZ") -> None: ...
    def copy(self) -> Euler: ...
    def freeze(self) -> Euler: ...
    def make_compatible(self, other: Euler) -> None: ...
    def rotate(self, other: Union[Euler, Quaternion, Matrix]) -> None: ...
    def rotate_axis(self, axis: str, angle: float) -> None: ...
    def to_matrix(self) -> Matrix: ...
    def to_quaternion(self) -> Quaternion: ...
    def zero(self) -> None: ...
    @property
    def is_frozen(self) -> bool: ...
    @property
    def is_wrapped(self) -> bool: ...
    order: str
    @property
    def owner(self) -> object: ...
    x: float
    y: float
    z: float

    # 以下、ドキュメントに存在しない
    @overload
    def __getitem__(self, index: int) -> float: ...
    @overload
    def __getitem__(
        self, index: slice[Optional[int], Optional[int], Optional[int]]
    ) -> tuple[float, ...]: ...
    def __setitem__(
        self,
        index: int,
        value: float,
    ) -> None: ...
